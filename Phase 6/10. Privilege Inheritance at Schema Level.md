# 10. Privilege Inheritance at Schema Level

Canonical documentation for [10. Privilege Inheritance at Schema Level](Phase 6/10. Privilege Inheritance at Schema Level.md). This document defines concepts, terminology, and standard usage.

## Purpose
Privilege inheritance at the schema level addresses the administrative overhead and security risks associated with managing granular access controls for individual database objects. In complex data environments, managing permissions for every table, view, or function independently is error-prone and difficult to audit. 

By establishing a mechanism where permissions can be defined at the schema (container) level and automatically applied to contained objects, organizations can ensure consistent security postures, simplify the onboarding of new data assets, and reduce the likelihood of "permission drift"â€”where objects within the same logical grouping have inconsistent access rules.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the logical architecture of schema-level security rather than specific vendor syntax.

## Scope
Clarify what is in scope and out of scope for this topic.

> [!IMPORTANT]
> **In scope:**
> * The logical hierarchy of permissions from schema to object.
> * Mechanisms for automatic privilege propagation (Default Privileges).
> * The relationship between schema ownership and object-level access.
> * Theoretical boundaries of inheritance versus explicit grants.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., PostgreSQL `ALTER DEFAULT PRIVILEGES` vs. SQL Server `GRANT ON SCHEMA`).
> * Row-level security (RLS) or Column-level security (CLS), which operate below the object level.
> * Network-level access controls or authentication protocols.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Schema** | A logical container within a database used to group related objects (tables, views, procedures). |
| **Privilege** | A defined right to perform a specific action (e.g., SELECT, INSERT, EXECUTE) on a resource. |
| **Inheritance** | The mechanism by which an object automatically acquires the security attributes of its parent container. |
| **Default Privileges** | A set of rules that define the permissions automatically applied to future objects created within a schema. |
| **Principal** | An entity (user, group, or role) that can be granted privileges. |
| **Effective Permissions** | The net result of all inherited and explicit privileges applied to a principal for a specific object. |

## Core Concepts
The fundamental idea behind schema-level inheritance is the "Container-Content" relationship. In a hierarchical security model, the schema acts as a security boundary.

### The Hierarchy of Access
Access is typically evaluated in a top-down or bottom-up fashion depending on the system architecture. Generally, a principal requires two levels of access to interact with an object:
1.  **Usage/Access on the Schema:** The right to "enter" the container.
2.  **Privilege on the Object:** The right to perform an action on the specific item inside.

### Propagation vs. Default Rules
Inheritance usually manifests in two ways:
*   **Live Inheritance:** Changes to the schema's permissions immediately affect all child objects.
*   **Creation-Time Inheritance (Default Privileges):** Rules that dictate what permissions are stamped onto an object at the moment of its creation.

> [!TIP]
> Think of a schema as a folder in a file system. If you give a user "Read" access to the folder, they should logically be able to read any new file dropped into that folder without an administrator manually granting permission to every new file.

## Standard Model
The standard model for schema-level inheritance follows the principle of **Least Privilege** while maximizing **Administrative Efficiency**.

1.  **Schema Usage:** A principal must first have the `USAGE` or `BROWSE` privilege on the schema. Without this, object-level privileges are typically unreachable.
2.  **Implicit Inheritance:** In many modern systems, granting `SELECT` at the schema level implicitly grants `SELECT` on all current and future tables/views within that schema.
3.  **Ownership Chain:** The owner of a schema often has implicit rights to manage all objects within that schema, regardless of who created the individual objects.
4.  **Precedence:** Explicitly defined object-level privileges usually override or supplement inherited privileges. If a user is denied access at the schema level, they are generally denied access to all objects within, regardless of object-level grants (the "Deny-Takes-Precedence" rule).

## Common Patterns

### The "Read-Only" Analytics Schema
A common pattern where a `REPORTER` role is granted `SELECT` and `USAGE` at the schema level. Any new data tables ingested into this schema are immediately available to the reporting tools without manual intervention.

### The "Application Owner" Schema
An application-specific role is granted full administrative rights (`ALL PRIVILEGES`) at the schema level. This allows the application's deployment pipeline to create, alter, and drop objects within its own namespace without requiring superuser intervention.

### Functional Role Mapping
Assigning privileges to roles (e.g., `Data_Scientist`, `ETL_Job`) at the schema level rather than to individual user accounts. This ensures that as personnel change, the security structure remains intact.

## Anti-Patterns

### Manual Per-Object Granting
Granting privileges on individual tables within a schema that houses hundreds of objects. This leads to "Permission Drift," where some tables are accidentally left insecure or inaccessible.

### Over-Privileging the `PUBLIC` Role
Granting schema-level inheritance to the `PUBLIC` or `EVERYONE` group. This effectively nullifies the schema as a security boundary.

### Circular Ownership
Situations where Object A in Schema 1 depends on Object B in Schema 2, and the owners of the schemas are different, leading to complex "Ownership Chaining" issues that bypass inheritance logic.

> [!CAUTION]
> Avoid granting `OWNERSHIP` at the schema level to transient user accounts. If the account is deleted, the entire schema and its inheritance chain may become orphaned or inaccessible.

## Edge Cases

### Object Re-creation
If an object (e.g., a table) is dropped and recreated with the same name, does it retain its old explicit privileges or inherit new ones from the schema? In most canonical models, the object is treated as "new" and follows the schema's default inheritance rules, losing any previous manual grants.

### Cross-Schema Views
A view in `Schema_A` that references a table in `Schema_B`. A user may have inherited `SELECT` on `Schema_A`, but if they lack `USAGE` on `Schema_B`, the inheritance chain may break depending on whether the system uses "Invoker's Rights" or "Definer's Rights."

### Renaming Schemas
Renaming a schema typically preserves the inheritance links, but if security scripts rely on hardcoded schema names to apply default privileges, the inheritance logic for *future* objects may fail.

## Related Topics
*   **Role-Based Access Control (RBAC):** The primary method for assigning the principals that benefit from inheritance.
*   **Ownership Chaining:** How the system validates access when objects reference other objects across schema boundaries.
*   **Least Privilege Principle:** The security philosophy that guides how inheritance should be restricted.
*   **Database-Level Inheritance:** The layer above schema inheritance where permissions flow from the database to the schema.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-26 | Initial AI-generated canonical documentation |