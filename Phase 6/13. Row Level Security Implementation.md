# 13. Row Level Security Implementation

Canonical documentation for [13. Row Level Security Implementation](Phase 6/13. Row Level Security Implementation.md). This document defines concepts, terminology, and standard usage.

## Purpose
Row Level Security (RLS) is a security architecture designed to restrict data access at the individual record level based on the characteristics of the user executing a query. While traditional database security focuses on object-level permissions (GRANT/REVOKE on tables or views), RLS provides a fine-grained access control layer that ensures users can only interact with the specific rows they are authorized to see or modify.

The primary problem space addressed by RLS is the "Multi-tenant Data Isolation" challenge. In shared database environments, RLS prevents "cross-tenant data leakage" by embedding access logic directly into the database engine, rather than relying solely on application-level filtering logic which is prone to developer error.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the architectural patterns of RLS rather than specific syntax for individual database engines.

## Scope
The scope of this document covers the theoretical framework, logical enforcement, and architectural patterns required to implement RLS effectively.

> [!IMPORTANT]
> **In scope:**
> * Predicate-based filtering mechanisms.
> * Security context propagation from application to database.
> * Policy evaluation logic (Permissive vs. Restrictive).
> * Performance implications of row-level predicates.

> [!WARNING]
> **Out of scope:**
> * Specific vendor implementations (e.g., PostgreSQL `CREATE POLICY`, SQL Server `SECURITY POLICY`).
> * Application-layer filtering (filtering data in the code after fetching it).
> * Physical data partitioning strategies.

## Definitions
| Term | Definition |
|------|------------|
| Predicate | A logical expression (Boolean) applied to each row to determine if it meets the criteria for access. |
| Security Context | The set of attributes (User ID, Role, Tenant ID) associated with the current database session. |
| Policy | A named rule that defines which operations (SELECT, INSERT, UPDATE, DELETE) a predicate applies to. |
| Tenant Isolation | The practice of ensuring one customer's data is invisible and inaccessible to another customer in a shared environment. |
| Trusted Context | A mechanism where the application identifies the end-user to the database, even when using a shared connection pool. |
| Leakproof Function | A function that does not reveal information about the arguments it receives, preventing side-channel data exposure. |

## Core Concepts
The fundamental idea of RLS is the **Transparent Filter**. When a user queries a table, the database engine automatically appends security predicates to the `WHERE` clause of the query.

### The Security Gatekeeper Analogy
> [!TIP]
> Think of a standard table as a large filing cabinet. Traditional security determines if you can open the cabinet. RLS is like a specialized pair of glasses: when you look into the cabinet, the glasses make every folder you aren't authorized to see completely invisible. You don't have to remember to look only at your folders; you simply cannot see the others.

### Policy Evaluation
RLS typically operates on two types of policies:
1.  **Permissive Policies:** Grant access if the predicate is met (logical OR).
2.  **Restrictive Policies:** Deny access if the predicate is not met, regardless of other policies (logical AND).

## Standard Model
The standard model for RLS implementation follows a three-tier execution flow:

1.  **Context Initialization:** The application borrows a connection from a pool and immediately sets a session-level variable (e.g., `current_user_id` or `tenant_id`).
2.  **Query Transformation:** When a DML statement is issued, the database engine intercepts the request and identifies all RLS policies bound to the target tables.
3.  **Predicate Injection:** The engine merges the policy predicates into the execution plan. The user only receives a result set containing rows where the predicate evaluated to `TRUE`.

> [!IMPORTANT]
> For RLS to be effective, the database user account used by the application must not be a "Superuser" or "Owner," as these roles typically bypass RLS checks by default.

## Common Patterns

### 1. The Tenant ID Pattern
The most common pattern in SaaS applications. Every table includes a `tenant_id` column. The RLS policy ensures that `table.tenant_id = session.current_tenant_id`.

### 2. The Managerial Hierarchy Pattern
Access is granted based on a recursive relationship. A user can see rows if the `owner_id` of the row reports to them in an `employees` table.

### 3. Role-Based Access Control (RBAC) Integration
Policies check the user's assigned roles against a required role attribute on the row. This allows for dynamic permissions where a "Manager" can see all rows in a department, but a "Staff" member can only see their own.

## Anti-Patterns

### 1. The "Leaky" Predicate
Using functions in a policy that have side effects or log errors. An attacker might craft a query that forces an error on rows they shouldn't see, revealing data through error messages.

### 2. Application-Only Filtering
Relying on the application to add `WHERE tenant_id = X` to every query. This is not true RLS and is highly susceptible to "Broken Object Level Authorization" (BOLA) vulnerabilities.

### 3. Over-Complex Predicates
Including heavy subqueries or joins within an RLS policy. Since the policy runs for every row (or every scan), complex logic can degrade performance from milliseconds to seconds.

> [!CAUTION]
> Avoid circular dependencies where a policy on Table A queries Table B, and Table B has a policy that queries Table A. This will result in infinite recursion or query failure.

## Edge Cases

### 1. Aggregation Leakage
Even if a user cannot see individual rows, a poorly configured system might allow them to run `COUNT(*)` on a table. If the count changes based on their input, they can infer the existence of data they cannot see.

### 2. "Upsert" Conflicts
In an `INSERT ... ON CONFLICT UPDATE` scenario, RLS may prevent a user from seeing a row, but the `INSERT` fails because the row already exists. This confirms the existence of a record belonging to another tenant.

### 3. Backup and Restore
System administrators performing backups must often bypass RLS to ensure all data is captured. If RLS is active during a backup, the resulting backup file will be incomplete and corrupted from a data integrity standpoint.

## Related Topics
*   **Column Level Security (CLS):** Restricting access to specific attributes within a row.
*   **Data Masking:** Obfuscating data (e.g., PII) rather than hiding the entire row.
*   **Attribute-Based Access Control (ABAC):** A more complex authorization model that often informs RLS predicates.
*   **Multi-tenancy Architectures:** The broader strategy of managing multiple customers in one system.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-26 | Initial AI-generated canonical documentation |