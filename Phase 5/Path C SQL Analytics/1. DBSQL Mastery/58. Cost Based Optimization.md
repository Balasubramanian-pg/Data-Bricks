# 058 Cost Based Optimization

Canonical documentation for 058 Cost Based Optimization. This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of Cost Based Optimization (CBO) is to determine the most efficient execution plan for a given operation—typically a data query—by evaluating the predicted resource consumption of multiple valid execution strategies. 

In complex data systems, there are often thousands of ways to retrieve and process a specific dataset (e.g., varying join orders, access paths, and parallelization levels). CBO addresses the limitations of Rule-Based Optimization (RBO) by incorporating the actual characteristics of the data (size, distribution, and cardinality) and the underlying hardware (I/O latency, CPU cycles, and network bandwidth) to make an informed selection.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **Statistical Analysis:** The role of data distribution and metadata in cost estimation.
* **Cost Modeling:** The mathematical frameworks used to calculate resource consumption.
* **Search Space Exploration:** The mechanisms for generating and pruning potential execution plans.
* **Decision Logic:** The criteria for selecting the "optimal" plan among candidates.

**Out of scope:**
* **Specific Vendor Implementations:** Syntax or proprietary algorithms specific to Oracle, PostgreSQL, Spark, or SQL Server.
* **Hardware-level Tuning:** Physical configuration of disks or memory (though the *cost* of these is in scope).
* **Rule-Based Optimization (RBO):** Except where used as a point of comparison.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Cardinality** | The estimated number of rows or records expected to be returned by a specific operation or operator. |
| **Selectivity** | A value between 0 and 1 representing the fraction of rows filtered by a predicate (e.g., a `WHERE` clause). |
| **Cost Function** | A mathematical formula that maps an execution plan to a numerical value representing resource usage (usually a combination of I/O, CPU, and Memory). |
| **Search Space** | The set of all valid execution plans generated by the optimizer for a single query. |
| **Histogram** | A statistical representation of data distribution within a column, used to improve cardinality estimates. |
| **Access Path** | The method used to retrieve data from a storage layer (e.g., Full Table Scan vs. Index Scan). |
| **Join Reordering** | The process of evaluating different sequences of joining multiple tables to minimize intermediate result sizes. |

## Core Concepts

### 1. The Cost Model
The cost model is the heart of CBO. It assigns a "weight" to different operations. 
* **I/O Cost:** The cost of reading/writing data blocks from persistent storage.
* **CPU Cost:** The cost of processing records (sorting, hashing, evaluating functions).
* **Network Cost:** In distributed systems, the cost of moving data between nodes (shuffling).

### 2. Statistics Collection
CBO is only as accurate as the data it consumes. Metadata must be maintained regarding:
* Table row counts.
* Number of distinct values (NDV) per column.
* Data skew (using histograms).
* Null density.

### 3. Plan Generation and Pruning
The optimizer generates a tree of operators. Because the number of permutations for a multi-way join is exponential, CBOs use techniques like **Dynamic Programming** or **Genetic Algorithms** to prune the search space, discarding high-cost paths early to keep optimization time within reasonable bounds.

## Standard Model
The standard model for CBO follows a linear pipeline:

1.  **Query Transformation:** The logical query is rewritten into equivalent but potentially more efficient forms (e.g., subquery flattening).
2.  **Candidate Generation:** The optimizer generates multiple physical execution plans for the transformed query.
3.  **Cost Estimation:** For each plan, the optimizer calculates the cost of every operator from the bottom up, using statistics to estimate the cardinality of intermediate results.
4.  **Plan Selection:** The plan with the lowest total cost is selected and passed to the execution engine.

## Common Patterns

### Join Optimization
The optimizer evaluates "Left-Deep," "Right-Deep," and "Bushy" trees. It typically seeks to perform the most restrictive filters first to reduce the volume of data passed to subsequent joins.

### Predicate Pushdown
Moving filters as close to the data source as possible. CBO uses this to reduce the cardinality of data before expensive operations like sorts or joins are performed.

### Materialization vs. Streaming
The optimizer decides whether to buffer intermediate results (materialize) or stream them to the next operator based on memory availability and the cost of re-computation.

## Anti-Patterns

### Stale Statistics
Relying on metadata that does not reflect the current state of the data. This leads to "Plan Regressions," where the optimizer chooses a sub-optimal path because it believes a table is smaller or more uniform than it actually is.

### Over-Optimization
Spending more time calculating the optimal plan than the actual execution of the query would take. This is common in "short-lived" queries where a simple heuristic would suffice.

### Hint Dependency
Hard-coding execution paths (Hints) to bypass the CBO. While sometimes necessary for edge cases, it creates technical debt and prevents the system from adapting to data growth or schema changes.

## Edge Cases

### Data Skew
When a specific value appears in a disproportionately high percentage of rows, standard selectivity formulas fail. Without high-resolution histograms, the CBO may underestimate the cost of processing that specific value.

### Correlated Columns
CBOs often assume that filters on different columns are independent. If `City = 'San Francisco'` and `ZipCode = '94105'`, the filters are highly correlated. Standard CBO logic would multiply their selectivities, resulting in an impossibly low cardinality estimate.

### Zero-Row/Small-Table Anomalies
In some models, the overhead of starting a parallel scan is higher than the cost of the scan itself. If statistics report 0 rows due to a delay in updates, the optimizer may choose an extremely inefficient plan (like a nested loop join on a massive table).

## Related Topics
* **021 Query Execution Engines:** The layer that consumes the plan produced by the CBO.
* **044 Distributed Systems Theory:** Relevant for understanding network cost components in CBO.
* **089 Indexing Strategies:** Defines the available access paths for the optimizer.
* **112 Materialized Views:** An alternative access path that the CBO must evaluate.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-11 | Initial AI-generated canonical documentation |